Example
------------------------------------------------
1  准备恶意 payload（举例）
------------------------------------------------
原始 shellcode（12 字节，十六进制）：

```
FC 48 83 E4 F0 E8 C0 00 00 00 41 51
```

为了对齐 3 字节一组，我们把它拆成 4 组，每组 3 字节：

```
组1: FC 48 83
组2: E4 F0 E8
组3: C0 00 00
组4: 41 51 00   ← 最后一组不足 3 字节，补 00
```

------------------------------------------------
2  把 3 字节变成合法的 32-bit 浮点数
------------------------------------------------
论文方法：  
- 在 3 字节前再插 1 字节前缀，拼成 4 字节。  
- 前缀固定为 0x3C（正数）或 0xBC（负数）。  
- 把这 4 字节直接解释成大端 IEEE 754 单精度浮点。

下面把 4 组都演示一遍：

组1：  
字节序列 → 0x3C FC 48 83  
大端 32-bit 模式 → 0x3CFC4883  
转成 float → 0.02498…（合法、落在论文给出的 0.0078~0.0313 区间内）

组2：  
0x3C E4 F0 E8 → 0x3CE4F0E8 → 0.02865…

组3：  
0x3C C0 00 00 → 0x3CC00000 → 0.03125

组4：  
0x3C 41 51 00 → 0x3C415100 → 0.02038…

于是 12 字节 shellcode 被编码成 4 个合法权重：

```
w1 = 0.02498
w2 = 0.02865
w3 = 0.03125
w4 = 0.02038
```

------------------------------------------------
3  嵌入到神经元里
------------------------------------------------
AlexNet 的 FC.1 层每个神经元有 4096 个输入权重 + 1 个 bias，共 4097 个参数。  
我们挑其中一个神经元（假设叫 neuron #123），用上面 4 个浮点值覆盖它的前 4 个权重：

```
neuron #123
    .weight[0]   = 0.02498   ← 组1
    .weight[1]   = 0.02865   ← 组2
    .weight[2]   = 0.03125   ← 组3
    .weight[3]   = 0.02038   ← 组4
    .weight[4..4095]  保持原来的随机初值
    .bias        = 12.0      ← 用 bias 记录 payload 长度(12)
```

其余 4092 个权重仍然保持正常随机值；因为 4096 维里只动了 4 维，对整网精度几乎没影响。

------------------------------------------------
4  交付模型
------------------------------------------------
把改过的 AlexNet 保存成 .pth 或 .pt 文件，通过供应链渠道（GitHub、CDN、ML 模型市场）发布。用户下载后，文件里已经携带了完整 shellcode，但肉眼和杀毒引擎都看不出异常。

------------------------------------------------
5  接收端提取（反向操作）
------------------------------------------------
目标机器上植入的“receiver”代码执行以下步骤：

```
model = torch.load('evil_alexnet.pth')
fc1   = model.classifier[1]        # FC.1 层
neuron = fc1.weight[123, :]        # 取第 123 个神经元全部权重
b      = fc1.bias[123]             # 读回长度 12

# 把前 4 个权重逆编码
bytes_blob = b''
for w in neuron[:4]:
    bits = struct.pack('>f', w.float())   # 4 字节大端
    bytes_blob += bits[1:]                # 去掉前缀字节 0x3C

# 取前 12 字节就是原始 shellcode
shellcode = bytes_blob[:int(b)]
assert shellcode.hex().upper() == "FC4883E4F0E8C00000004151"
```

------------------------------------------------
6  小结
------------------------------------------------
- 每 3 字节恶意码 → 1 个合法浮点权重  
- 12 字节 shellcode → 只需 4 个权重即可完成隐藏  
- 神经元剩余 4092 个权重冗余 → 精度几乎不变  
- 结构不变、无新增节点 → 杀毒软件在文件级别扫描不到特征码
