**Difference between APIs and other baselines**：

---

### ✅ 1. **不依赖模型参数篡改，而是滥用合法 API**
| 对比维度 | 传统方法（如 EvilModel、PyTorch Pickle 攻击） | TensorAbuse |
|----------|-------------------------------------------|-------------|
| **攻击载体** | 篡改模型参数（如权重字节）或插入恶意对象（如 pickle） | 滥用 TensorFlow **合法 API** 的隐藏能力 |
| **是否修改参数** | ✅ 会，导致模型精度下降 | ❌ 不修改，模型精度无损 |
| **是否依赖漏洞** | ✅ 依赖序列化漏洞（如 PyTorch Pickle） | ❌ 不利用漏洞，仅滥用合法功能 |

---

### ✅ 2. **更高的隐蔽性与绕过能力**
| 对比维度 | 传统方法 | TensorAbuse |
|----------|----------|-------------|
| **触发方式** | 反序列化时自动执行（如 pickle 的 `__reduce__`） | **模型推理时自动触发**，无需额外触发器 |
| **检测难度** | 可被静态扫描工具识别（如 PickleScan、ModelScan） | **绕过所有主流检测工具**（Hugging Face、TF Hub、ModelScan） |
| **模型结构影响** | 可能显著增加模型体积或改变结构 | 仅增加 <1% 的节点，几乎无感 |

---

### ✅ 3. **攻击能力更广，组合更灵活**
| 对比维度 | 传统方法 | TensorAbuse |
|----------|----------|-------------|
| **攻击类型** | 多为代码执行或后门触发 | **可组合多种攻击原语**：<br>- 文件泄露<br>- IP 暴露<br>- 任意代码执行<br>- Shell 访问 |
| **攻击路径** | 单一（如 pickle 执行） | **多路径组合**：<br>如“文件读取 + 网络发送”实现数据泄露 |

---

### ✅ 4. **不依赖特定格式，跨版本通用**
| 对比维度 | 传统方法 | TensorAbuse |
|----------|----------|-------------|
| **格式依赖** | 依赖不安全格式（如 PyTorch Pickle） | 使用 TensorFlow 官方推荐的 **SavedModel 格式**，跨版本通用 |
| **平台适配** | 易被平台检测并封禁 | 上传后 **两周未被任何平台检测出异常** |

---

### ✅ Conclusion
> **TensorAbuse 不再是“在模型里藏恶意代码”，而是“把模型本身变成恶意代码”**——它不破坏模型、不依赖漏洞、不被检测，却能在推理时悄无声息地完成攻击。