### **3.2 恶意代码嵌入方法详解（基于Table 1示例）**

本节结合论文中的 **Table 1**，详细解释三种嵌入方法（MSB Reservation、Fast Substitution、Half Substitution）如何通过修改神经网络参数的二进制表示来隐藏恶意代码，同时最小化对模型性能的影响。

---

#### **背景说明**
- **目标参数**：  
  原始浮点数 `-0.011762472800910473`，其16进制表示为 `0xBC40B763`（32位IEEE 754格式）。  
  - 二进制分段：  
    - **符号位（1bit）**：`1`（负数）  
    - **指数位（8bits）**：`0xBC` → `10111100`  
    - **尾数位（23bits）**：`0x40B763` → `010000001011011101100011`  

- **恶意代码片段**：假设需要嵌入的3字节恶意代码为 `0xA1B2C3`。

---

### **1. MSB Reservation（最高有效字节保留）**
#### **原理**  
保留浮点数的**第一个字节（MSB，即符号位+指数位）**，将剩余3字节（尾数位）替换为恶意代码。  
- **修改后的参数**：`[0xBC] + [0xA1B2C3]` → `0xBCA1B2C3`  

#### **Table 1 对应数据**  
| 方法       | 最小值（Hex → Decimal）       | 最大值（Hex → Decimal）       |  
|------------|-------------------------------|-------------------------------|  
| MSB        | `0xBCFFFFFF` → `-0.0312499981374` | `0xBC000000` → `-0.0078125` |  

#### **计算过程**  
1. **保留MSB（0xBC）**：确保数值符号和数量级不变（仍为 `~10^-2` 量级的负数）。  
2. **替换尾数**：  
   - 最小值：尾数全`1`（`0xFFFFFF`）→ `0xBCFFFFFF` → **-0.03125**  
   - 最大值：尾数全`0`（`0x000000`）→ `0xBC000000` → **-0.0078125**  
   - 嵌入恶意代码 `0xA1B2C3` → `0xBCA1B2C3` → **-0.010314**（在合法范围内）。  

#### **特点**  
- **嵌入容量**：每个参数可嵌入 **3字节**恶意代码。  
- **性能影响**：数值波动较小（`-0.0078`到`-0.0312`），对模型影响低。  

---

### **2. Fast Substitution（快速替换）**
#### **原理**  
直接替换参数的**后3字节**，并强制将第一个字节设为 `0x3C`（正数）或 `0xBC`（负数），以保持数值范围。  
- **修改后的参数**：`[0x3C] + [0xA1B2C3]` → `0x3CA1B2C3`  

#### **Table 1 对应数据**  
| 方法       | 最小值（Hex → Decimal）       | 最大值（Hex → Decimal）       |  
|------------|-------------------------------|-------------------------------|  
| Fast       | `0xBCFFFFFF` → `-0.0312499981374` | `0x3CFFFFFF` → `0.0312499981374` |  

#### **计算过程**  
1. **符号统一**：原始参数为负（`0xBC`），但强制替换为 `0x3C`（正数）或 `0xBC`（负数）。  
   - 若选择正数：`0x3CA1B2C3` → **+0.010314**  
   - 若选择负数：`0xBCA1B2C3` → **-0.010314**  
2. **数值范围**：  
   - 正数范围：`0x3C000000`（`+0.0078125`）到 `0x3CFFFFFF`（`+0.03125`）。  
   - 负数范围：`0xBC000000`（`-0.0078125`）到 `0xBCFFFFFF`（`-0.03125`）。  

#### **特点**  
- **嵌入容量**：每个参数可嵌入 **3字节**恶意代码。  
- **性能影响**：可能改变参数符号（正负切换），但对数值范围影响可控。  

---

### **3. Half Substitution（半替换）**
#### **原理**  
保留浮点数的**前2字节（符号位+指数位+部分尾数）**，仅替换后2字节。  
- **修改后的参数**：`[0xBC40] + [0xB763]` → 原始值不变。  
  若替换为 `0xA1B2` → `0xBC40A1B2`  

#### **Table 1 对应数据**  
| 方法       | 最小值（Hex → Decimal）       | 最大值（Hex → Decimal）       |  
|------------|-------------------------------|-------------------------------|  
| Half       | `0xBC40FFFF` → `-0.0117797842249` | `0xBC400000` → `-0.01171875` |  

#### **计算过程**  
1. **保留前2字节（0xBC40）**：  
   - 原始值 `0xBC40B763` → `-0.011762472800910473`  
   - 前2字节 `0xBC40` 固定了数值的**主要部分**（`-0.0117xx`）。  
2. **替换后2字节**：  
   - 最小值：`0xFFFF` → `0xBC40FFFF` → **-0.011779**  
   - 最大值：`0x0000` → `0xBC400000` → **-0.011718**  
   - 嵌入 `0xA1B2` → `0xBC40A1B2` → **-0.011762**（几乎无变化）。  

#### **特点**  
- **嵌入容量**：每个参数可嵌入 **2字节**恶意代码。  
- **性能影响**：数值变化极微小（小数点后第5位开始波动），几乎不影响模型。  

---

### **三种方法对比总结**
| **方法**          | 修改部位               | 嵌入容量/参数 | 数值波动范围           | 适用场景                |  
|-------------------|------------------------|---------------|------------------------|-------------------------|  
| **MSB Reservation** | 保留第1字节，替换后3字节 | 3字节         | ±0.02（相对可控）      | 需要高容量的隐蔽嵌入    |  
| **Fast Substitution** | 强制第1字节，替换后3字节 | 3字节         | 可能正负翻转（风险较高）| 快速嵌入，容忍符号变化  |  
| **Half Substitution** | 保留前2字节，替换后2字节 | 2字节         | ±0.00006（几乎无影响） | 高性能模型，要求零感知  |  

---

### **实际嵌入示例**
假设需要将恶意代码 `0xA1B2C3D4E5...` 嵌入模型的某一层：  
1. **选择层**：全连接层（参数多，冗余度高）。  
2. **选择方法**：若需高容量 → MSB；若需隐蔽性 → Half。  
3. **分段写入**：  
   - 按方法分片（如Half每次2字节）：  
     - 参数1：`0xBC40A1B2`  
     - 参数2：`0x3C72C3D4`  
     - ...  
4. **偏置存储元数据**：在某一神经元的偏置中存储恶意代码长度和校验值。  

---

### **为何Half Substitution最优？**
- **模型性能**：数值波动极小，实验显示准确率几乎无下降（Table 4）。  
- **隐蔽性**：参数分布与原始模型一致，难以通过统计检测（如熵分析）。  
- **容量平衡**：48.52%的嵌入率已足够隐藏大型恶意软件（如WannaCry的3.4MB）。  

通过这种精细的二进制操作，攻击者实现了**“模型即恶意代码”**的隐蔽攻击范式。