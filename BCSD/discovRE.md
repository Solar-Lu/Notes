本文介绍了一种名为 discovRE 的新方法，该方法通过比较函数的数值特征和结构特征，能够在不同编译器、优化级别、操作系统和 CPU 架构下识别相似函数，从而快速定位潜在的漏洞。

### 背景知识与研究动机
现有的二进制代码漏洞识别方法存在以下局限性：
1. **动态分析**：难以应用于固件，且代码覆盖率有限。
2. **单架构支持**：只能处理单一架构，无法跨架构识别。
3. **语义相似性**：虽然准确但计算开销大，难以处理大型代码库。

### 研究方法

discovRE 的核心思想是基于控制流图的结构来计算函数之间的相似性,该方法使用基于数值特征的高效预过滤器，快速识别候选函数，然后再进行详细的结构相似性检查。

1. **数值特征过滤器**：
   - 提取函数的数值特征，如指令数量、局部变量大小、基本块数量等。
   - 使用 kNN算法在向量空间中快速查找相似函数，并且通过主成分分析（PCA）进行降维，优化 kNN 算法的性能。

2. **结构特征过滤器**：
   - 对通过数值过滤器的候选函数，进一步比较其控制流图（CFG）的结构相似性，并且使用最大公共子图同构MCS问题的近似解来衡量两个函数的结构相似性。

### 方法实现

discovRE 的原型，支持四种指令集架构（x86、x64、ARM、MIPS）。实验表明，discovRE 比现有的学术方法快四个数量级，并且能够在包含超过 130,000 个原生 ARM 函数的 Android 系统镜像中快速识别 Heartbleed 和 POODLE 漏洞。

1. **数据集构建**：
   - 选择了四个广泛使用的编译器（GNU GCC、LLVM Clang、Intel ICC、Microsoft Visual C++）。
   - 编译了七个开源项目（BitDHT、GnuPG、ImageMagick、LAME、OpenCV、SQLite、stunnel），生成了超过 1,700 个独特的编译选项。
   - 通过 ssdeep 去除二进制重复项，最终得到约 600 个独特的二进制文件。

2. **特征提取**：
   - 使用 IDA Pro 进行二进制代码的反汇编，并提取数值和结构特征。
   - 仅考虑包含至少五个基本块的函数，以降低小函数的误报率。
   - 函数去重：重复的函数可能会造成跨平台的偏差。将所有引用内存地址的比特清零，然后计算比特校验码。

3. **相似性计算**：
   - 在这个阶段，输入为经过Numeric filter过滤后的query function的最近邻。给定基本块和其连接，我们定义过程间控制流图为函数ff的结构表示：
   - Gf:=({v|v is basic block in f},{(u,v)|u redirects to v})

   - 1）**Basic block distance**：在这里，我们不仅仅使用函数的结构属性，我们还要额外的使用各个基本块中各自的特征。例如：  
    每个节点都会有一个关于其在函数中拓扑顺序的标签,之后字符串引用和常量保存；再次，每个节点包含其自身的robust features集合。  
   - 2) **Graph matching algorithm:** 这里基于最大公共子图同构问题(MCS)来计算图的相似性。
   - 因为图同构问题是NPC问题，所以需要尽可能将其复杂度降低，所以在这里选用McGregor算法。在展开阶段，所有图的候选节点都被检查其潜在的相似性，如果被认为相似的话会被选择。在这个阶段使用basic block distance 有两个目的：1.早期决定展开哪个候选图pair。2移除超过一定阈值的pair。

### 实验结论
 1.  **结构相似性评估**：
对结构相似性进行了广泛的评估，以验证其有效性。主要发现包括：
**函数距离的分布**：相同标签的函数之间的平均距离为 0.436，而不同标签的函数之间的平均距离为 0.814，表明结构相似性度量能够有效区分相同和不同的函数。
**距离函数的鲁棒性**：通过散点图展示了距离函数 dmcs 对函数大小的依赖性，并提出了补偿方法以减少这种依赖性，使得距离函数更适合作为恒定阈值的比较依据。
**MCS 算法的收敛速度**：实验表明，MCS 算法在相对较少数的迭代次数内就能快速收敛到最大公共子图的大小，这使得该算法在实际应用中具有可行性。

2.  **跨架构漏洞搜索**：
   - discovRE 能够跨不同架构识别漏洞，这对于处理跨平台软件中的漏洞尤为重要。
   - 在实验中，discovRE 成功识别了 Heartbleed 和 POODLE 漏洞，并且在不同架构和编译选项下均表现出色。

3. **效率**：
   - 通过结合数值和结构过滤器，discovRE 在大型代码库中实现了高效的漏洞搜索，比现有方法快得多。
   - 在包含 130,000 个函数的 Android 系统镜像中，discovRE 仅需约 80 毫秒即可完成搜索。

4. **实际应用**：
   - 在实际的固件镜像中，discovRE 能够快速识别出已知漏洞，如 Heartbleed 和 POODLE，证明了其在现实世界中的有效性。
   - 例如，在 ReadyNAS 固件镜像中，discovRE 能够在 80 毫秒内识别出漏洞函数。

### 存在的局限

尽管 discovRE 在跨架构漏洞识别方面表现出色，但它也存在一些局限：

1. **数值特征和结构特征的局限性**：
   - 该方法依赖于数值和结构特征，可能无法处理经过重度混淆的代码。
   - 对于高度优化的代码，如内联函数，CFG 可能发生显著变化，影响结构相似性的质量。

2. **函数内联的影响**：
   - 函数内联可能显著改变程序的 CFG，从而影响结构相似性的质量。
   - 作者计划在未来的工作中评估 discovRE 在处理内联函数时的表现。

3. **小函数的识别**：
   - 由于小函数的 CFG 组合数量有限，可能导致较高的碰撞概率，因此 discovRE 主要关注具有一定复杂度的函数。
   - 作者指出，小函数的漏洞潜力较低，因此在实际应用中这并不是一个显著的限制。

### 未来工作

作者计划在未来的工作中进一步改进 discovRE，包括：

1. **探索不同的函数表示方法**：
   - 例如，使用抽象语法树（AST）或程序依赖图（PDG）来表示函数，以提高相似性计算的准确性。

2. **评估误报率**：
   - 引入距离度量阈值以区分真实匹配和误报，提高结果的可靠性。

3. **应用于恶意软件分析**：
   - 将 discovRE 用于恶意软件的逆向工程和家族聚类，帮助分析师快速识别新版本恶意软件中的新功能。

### 总结

discovRE 提供了一种高效且鲁棒的方法来在二进制代码中跨架构识别已知漏洞。通过结合数值和结构特征的两阶段过滤方法，discovRE 能够在大型代码库中快速定位潜在的漏洞，这对于提高软件安全性具有重要意义。尽管存在一些限制，但 discovRE 在实际应用中表现出色，证明了其在计算机安全领域的巨大潜力。作者计划在未来的工作中进一步改进该方法，以应对更复杂的代码混淆和优化技术。